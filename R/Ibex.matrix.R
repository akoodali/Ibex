#' Ibex Matrix Interface
#'
#' This function runs the Ibex algorithm to generate latent vectors from 
#' input data. The output can be returned as a matrix, with options to choose 
#' between deep learning autoencoders or geometric transformations based on 
#' the BLOSUM62 matrix.
#'
#' @examples
#' # Using the encoder method with a variational autoencoder
#' ibex_values <- Ibex.matrix(ibex_example, 
#'                            chain = "Heavy",
#'                            method = "encoder",
#'                            encoder.model = "VAE",
#'                            encoder.input = "atchleyFactors")
#'
#' # Using the geometric method with a specified angle
#' ibex_values <- Ibex.matrix(ibex_example, 
#'                            chain = "Heavy",
#'                            method = "geometric",
#'                            geometric.theta = pi)
#'
#' @param input.data Input data, which can be:
#'   \itemize{
#'     \item A Single Cell Object in Seurat or SingleCellExperiment format
#'     \item The output of \code{combineBCR()} from the \code{scRepertoire} package
#'   }
#' @param chain Character. Specifies which chain to analyze:
#'   \itemize{
#'     \item "Heavy" for the heavy chain
#'     \item "Light" for the light chain
#'   }
#' @param method Character. The algorithm to use for generating latent vectors:
#'   \itemize{
#'     \item "encoder" - Uses deep learning autoencoders
#'     \item "geometric" - Uses geometric transformations based on the 
#'     BLOSUM62 matrix
#'   }
#' @param encoder.model Character. The type of autoencoder model to use:
#'   \itemize{
#'     \item "CNN" - CDR3 Convolutional Neural Network-based autoencoder
#'     \item "VAE" - CDR3 Variational Autoencoder
#'     \item "CNN.EXP" - CDR1/2/3 CNN
#'     \item "VAE.EXP" - CDR1/2/3 VAE
#'   }
#' @param encoder.input Character. Specifies the input features for the 
#' encoder model. Options include:
#'   \itemize{
#'     \item Amino Acid Properties: "atchleyFactors", "crucianiProperties", 
#'    "kideraFactors", "MSWHIM","tScales", "zScales"
#'     \item "OHE" for One Hot Encoding 
#'   }
#' @param geometric.theta Numeric. Angle (in radians) for the geometric 
#' transformation. Only used when \code{method = "geometric"}.
#' @param species Character. Default is "Human" or "Mouse".
#' @param verbose Logical. Whether to print progress messages. Default is TRUE.
#' @return A matrix of latent vectors generated by the specified method.
#'
#' @export
#' @importFrom basilisk basiliskRun                         
#' @importFrom SeuratObject CreateDimReducObject
#' @importFrom immApex propertyEncoder onehotEncoder geometricEncoder getIR
#' @importFrom stats complete.cases
#' @importFrom tensorflow tf
#' 
#' @seealso 
#' \code{\link[immApex]{propertyEncoder}}, 
#' \code{\link[immApex]{geometricEncoder}}
Ibex.matrix <- function(input.data, 
                        chain = c("Heavy", "Light"), 
                        method = c("encoder", "geometric"),
                        encoder.model = c("CNN", "VAE", "CNN.EXP", "VAE.EXP"), 
                        encoder.input = c("atchleyFactors", "crucianiProperties", 
                                          "kideraFactors", "MSWHIM", "tScales", "OHE"),
                        geometric.theta = pi/3, 
                        species = "Human",
                        verbose = TRUE) {
  
  cat("--- Running AKN patched version of Ibex.matrix ---\n")

  # Match arguments for better validation
  chain <- match.arg(chain)
  method <- match.arg(method)
  
  if (method == "encoder") {
    encoder.model <- match.arg(encoder.model)
    encoder.input <- match.arg(encoder.input)
    expanded.sequences <- grepl(".EXP", encoder.model)
  } else {
    expanded.sequences <- FALSE
  }
  
  # Define loci based on chain selection
  loci <- if (chain == "Heavy") "IGH" else c("IGK", "IGL")
  
  #Getting Sequences
  BCR <- getIR(input.data, chain, sequence.type = "aa")
  BCR <- BCR[complete.cases(BCR[,2]), ]
  
  # Determine dictionary for sequence encoding
  if (expanded.sequences) {
    if (all(grepl("-", BCR[,2]))) {
      stop("Expanded sequences are not properly formated, please use combineExpandedBCR().")
    }
    BCR[,2] <- gsub("-", "_", BCR[,2])
    dictionary <- c(amino.acids, "_")
  } else  {
    dictionary <- amino.acids
  }
  
  # Filter by gene locus
  BCR <- BCR[grepl(paste0(loci, collapse = "|"), BCR[, "v"]), ]
  
  # Ensure sequences meet length criteria
  checkLength(x = BCR[,2], expanded = expanded.sequences)
  length.to.use <- if (expanded.sequences) 90 else 45
  
  if (method == "encoder") {
    # Getting Model Path
    model.path <- aa.model.loader(species      = species,  
                                  chain        = chain,
                                  encoder.input = encoder.input,
                                  encoder.model = encoder.model)
    
    if (verbose) print("Encoding sequences and calculating latent dimensions...")
    
    # Run ENCODING and PREDICTION inside the basilisk environment
    reduction <- basiliskRun(
      env = .get_ibex_env(),
      fun = function(sequences, enc.input, max.len, seq.dict, mpath, verbose.fun) {
        
        # 1. Encode sequences inside the correct environment
        if(enc.input == "OHE") {
          encoded.values <- immApex::onehotEncoder(sequences,
                                                   max.length = max.len,
                                                   convert.to.matrix = TRUE,
                                                   sequence.dictionary = seq.dict,
                                                   padding.symbol = ".")
        } else {
          encoded.values <- immApex::propertyEncoder(sequences, 
                                                     max.length = max.len,
                                                     method.to.use = enc.input,
                                                     convert.to.matrix = TRUE)
        }
        
        # 2. Load model and predict
        keras <- reticulate::import("keras", delay_load = FALSE)
        model <- keras$models$load_model(mpath)  
        pred  <- model$predict(encoded.values)
        
        return(as.array(pred))
      },
      # Pass arguments to the function inside basiliskRun
      sequences = BCR[,2],
      enc.input = encoder.input,
      max.len   = length.to.use,
      seq.dict  = dictionary,
      mpath     = model.path
    )
    
  } else if (method == "geometric") {
    if (verbose) print("Performing geometric transformation...")
    BCR[,2] <- gsub("-", "", BCR[,2])
    reduction <- suppressMessages(geometricEncoder(BCR[,2], theta = geometric.theta))
  }
  
  reduction <- as.data.frame(reduction)
  barcodes <- BCR[,1]
  rownames(reduction) <- barcodes
  colnames(reduction) <- paste0("Ibex_", seq_len(ncol(reduction)))
  return(reduction)
}